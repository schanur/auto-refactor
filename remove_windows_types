#!/usr/bin/ruby

require 'pp'

$int_type_conversion = [
  ["FLOAT",     "float"],
  ["DOUBLE",    "double"],
  ["UINT",      "unsigned int"],
  ["INT",       "int"],
  ["USHORT",    "uint16_t"],
  ["SHORT",     "int16_t"],
  ["BYTE",      "uint8_t"],
  ["BOOL",      "bool"],
  ["DWORD",     "uint32_t"],
  ["WORD",      "uint16_t"],
  ["WCHAR",     "wchar_t"],
  ["UCHAR",     "uint8_t"],
  ["CHAR",      "char"]
]


$namespace_conversion = [
  ["wstring",   "std::wstring"],
  ["string",    "std::string"],
  ["vector",    "std::vector"],
  ["map",       "std::map"],
  ["list",      "std::list"]
]

$other_conversion = [
 ["wchat_t",   "wchar_t"]
]

$type_barrier_character_list             = [' ', '[', ']', '<', '>']# , '(', ')']
$type_barrier_character_list_regex_str   = [' ', '[', ']', '<', '>']# , '(', ')']
# $avoid_include                           = '(?!#include\ )'
$type_barrier_regex_start                = '([' + Regexp.quote($type_barrier_character_list.join("")) + '^])'
$type_barrier_regex_end                  = '([' + Regexp.quote($type_barrier_character_list.join("")) + '$])'

def string_pair_to_type_regex(search_replace_pair)
  # raise "Bad parameter: search_replace_pair: " if
  # pp search_replace_pair
  # replace_regex = Regexp.new(Regexp.quote 'b')
  search_regex  = Regexp.new($type_barrier_regex_start + Regexp.quote(search_replace_pair[0]) + $type_barrier_regex_end)
  # search_regex  = Regexp.new(Regexp.quote "(#{$type_barrier_start_regex}#{search_replace_pair[0]}#{$type_barrier_end_regex})")
  # replace_regex = "\\1#{search_replace_pair[1]}\\2"
  replace_regex = '\1' + Regexp.quote(search_replace_pair[1]) + '\2'
  return [search_regex, replace_regex]
end

def replace_regex_list_in_array(data, regex_list)
  return data if regex_list.empty?
  regex = regex_list[0]
  new_data = data.map.with_index { |line, i|
    begin
      if line.include? '#include '
        line
      else
        line.gsub(regex[0], regex[1])
      end
    rescue
      puts "Failed to parse line " + i.to_s + ":" + line
      exit 1
    end
  }
  replace_regex_list_in_array(new_data, regex_list.drop(1))
end

def find_header_inclusion_position(data)
  last_preprocessor_line = 0
  data.each.with_index { |line, i|
    if line.include? '#include ' or line.include? '#define' or  /^\ *$/ =~ line
      last_preprocessor_line = i
    else
      break;
    end
  }
  last_preprocessor_line
end

# def ensure_platform_inttypes_header_present(data)
#   if data
# end

#Return array of lines of file.
def read_file_as_array(filename)
  File.open(filename, "rb:iso-8859-1").each.to_a
end



filename = ARGV[0]

file_data = read_file_as_array(filename)

regex_int_type  = $int_type_conversion.map  { |type| string_pair_to_type_regex(type) }
regex_namespace = $namespace_conversion.map { |type| string_pair_to_type_regex(type) }
regex_other     = $other_conversion.map     { |type| string_pair_to_type_regex(type) }

post_int_type_conversion = replace_regex_list_in_array(file_data, regex_int_type)

if not post_int_type_conversion.eql? file_data
  puts find_header_inclusion_position(post_int_type_conversion)
  #File.rename(filename, filename + '.orig'
  #File.delete(filename)
  #File.open(filename, 'w') { |f| post_type_conversion.each { |line| f << line } }
end
  # puts new_data
